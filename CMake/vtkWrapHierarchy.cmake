#
# a cmake macro to generate a text file with the class hierarchy
#
MACRO(VTK_WRAP_HIERARCHY TARGET OUTPUT_DIR SOURCES)
  IF(NOT VTK_WRAP_HIERARCHY_EXE)
    MESSAGE(SEND_ERROR "VTK_WRAP_HIERARCHY_EXE not specified when calling VTK_WRAP_HIERARCHY")
  ENDIF(NOT VTK_WRAP_HIERARCHY_EXE)

  # The shell into which nmake.exe executes the custom command has some issues
  # with mixing quoted and unquoted arguments :( Let's help.

  IF(CMAKE_GENERATOR MATCHES "NMake Makefiles")
    SET(verbatim "")
    SET(quote "\"")
  ELSE(CMAKE_GENERATOR MATCHES "NMake Makefiles")
    SET(verbatim "VERBATIM")
    SET(quote "")
  ENDIF(CMAKE_GENERATOR MATCHES "NMake Makefiles")

  SET(TMP_INCLUDE)
  FOREACH(INCLUDE_DIR ${VTK_INCLUDE_DIRS})
    SET(TMP_INCLUDE "${TMP_INCLUDE}-I ${quote}${INCLUDE_DIR}${quote}\n")
  ENDFOREACH(INCLUDE_DIR ${VTK_INCLUDE_DIRS})

  # write wrapper-tool arguments to a file
  STRING(STRIP "${TMP_INCLUDE}" CMAKE_CONFIGURABLE_FILE_CONTENT)
  SET(RESPONSE_FILE ${OUTPUT_DIR}/${TARGET}.args)
  CONFIGURE_FILE(${CMAKE_ROOT}/Modules/CMakeConfigurableFile.in
                 ${RESPONSE_FILE} @ONLY)

  SET(VTK_WRAPPER_INIT_DATA)

  # list of used files
  SET(INPUT_FILES)

  # For each class
  FOREACH(FILE ${SOURCES})
    # should we wrap the file?
    #GET_SOURCE_FILE_PROPERTY(TMP_WRAP_EXCLUDE ${FILE} WRAP_EXCLUDE)
    #GET_SOURCE_FILE_PROPERTY(TMP_WRAP_SPECIAL ${FILE} WRAP_SPECIAL)
    IF (VTK_CLASS_ABSTRACT_${FILE} OR
        ${KIT_NAME}_HEADER_${FILE}_ABSTRACT)
      SET(TMP_ABSTRACT 1)
    ELSE (VTK_CLASS_ABSTRACT_${FILE} OR
          ${KIT_NAME}_HEADER_${FILE}_ABSTRACT)
      SET(TMP_ABSTRACT 0)
    ENDIF (VTK_CLASS_ABSTRACT_${FILE} OR
           ${KIT_NAME}_HEADER_${FILE}_ABSTRACT)
    IF (VTK_CLASS_WRAP_SPECIAL_${FILE} OR
        ${KIT_NAME}_HEADER_${FILE}_WRAP_SPECIAL)
      SET(TMP_WRAP_SPECIAL 1)
    ELSE (VTK_CLASS_WRAP_SPECIAL_${FILE} OR
          ${KIT_NAME}_HEADER_${FILE}_WRAP_SPECIAL)
      SET(TMP_WRAP_SPECIAL 0)
    ENDIF (VTK_CLASS_WRAP_SPECIAL_${FILE} OR
           ${KIT_NAME}_HEADER_${FILE}_WRAP_SPECIAL)
    IF (VTK_CLASS_WRAP_EXCLUDE_${FILE} OR
        ${KIT_NAME}_HEADER_${FILE}_WRAP_EXCLUDE)
      SET(TMP_WRAP_EXCLUDE 1)
    ELSE (VTK_CLASS_WRAP_EXCLUDE_${FILE} OR
          ${KIT_NAME}_HEADER_${FILE}_WRAP_EXCLUDE)
      SET(TMP_WRAP_EXCLUDE 0)
    ENDIF (VTK_CLASS_WRAP_EXCLUDE_${FILE} OR
           ${KIT_NAME}_HEADER_${FILE}_WRAP_EXCLUDE)

    # if we should wrap it
    IF (TMP_WRAP_SPECIAL OR IGNORE_WRAP_EXCLUDE OR NOT TMP_WRAP_EXCLUDE)
      # what is the filename without the extension
      GET_FILENAME_COMPONENT(TMP_FILENAME ${FILE} NAME_WE)

      # the input file might be full path so handle that
      GET_FILENAME_COMPONENT(TMP_FILEPATH ${FILE} PATH)

      # compute the input filename
      IF (TMP_FILEPATH)
        SET(TMP_INPUT "${TMP_FILEPATH}/${TMP_FILENAME}.h")
      ELSE (TMP_FILEPATH)
        IF (H_${TMP_FILENAME})
          IF (NOT EXISTS "${H_${TMP_FILENAME}}")
            SET (H_${TMP_FILENAME} "H_${TMP_FILENAME}-NOTFOUND")
          ENDIF (NOT EXISTS "${H_${TMP_FILENAME}}")
        ENDIF (H_${TMP_FILENAME})
        FIND_FILE(H_${TMP_FILENAME} "${TMP_FILENAME}.h" PATHS ${KIT_HEADER_DIR})
        MARK_AS_ADVANCED(H_${TMP_FILENAME})
        SET (TMP_INPUT ${H_${TMP_FILENAME}})
      ENDIF (TMP_FILEPATH)

      IF(TMP_INPUT)
      IF(NOT "${TMP_FILENAME}" STREQUAL "vtkgl" AND
         NOT "${TMP_FILENAME}" STREQUAL "vtkOpenGLState")
      IF(NOT "${KIT_NAME}" STREQUAL "Filtering" OR
         NOT "${TMP_FILENAME}" STREQUAL "vtkInformation")

        # add to the INPUT_FILES
        SET(INPUT_FILES ${INPUT_FILES} ${TMP_INPUT})

        # add the info to the init file
        SET(VTK_WRAPPER_INIT_DATA
          "${VTK_WRAPPER_INIT_DATA}${TMP_INPUT};${KIT_TARGET_NAME}")

        IF (TMP_ABSTRACT)
          SET(VTK_WRAPPER_INIT_DATA "${VTK_WRAPPER_INIT_DATA};ABSTRACT")
        ENDIF (TMP_ABSTRACT)

        IF (TMP_WRAP_EXCLUDE)
          SET(VTK_WRAPPER_INIT_DATA "${VTK_WRAPPER_INIT_DATA};WRAP_EXCLUDE")
        ENDIF (TMP_WRAP_EXCLUDE)

        IF (TMP_WRAP_SPECIAL)
          SET(VTK_WRAPPER_INIT_DATA "${VTK_WRAPPER_INIT_DATA};WRAP_SPECIAL")
        ENDIF (TMP_WRAP_SPECIAL)

        SET(VTK_WRAPPER_INIT_DATA "${VTK_WRAPPER_INIT_DATA}\n")

      ENDIF(NOT "${KIT_NAME}" STREQUAL "Filtering" OR
            NOT "${TMP_FILENAME}" STREQUAL "vtkInformation")
      ENDIF(NOT "${TMP_FILENAME}" STREQUAL "vtkgl" AND
            NOT "${TMP_FILENAME}" STREQUAL "vtkOpenGLState")
      ENDIF(TMP_INPUT)
    ENDIF (TMP_WRAP_SPECIAL OR IGNORE_WRAP_EXCLUDE OR NOT TMP_WRAP_EXCLUDE)
  ENDFOREACH(FILE)

  # finish the data file for the init file
  CONFIGURE_FILE(
    ${VTK_CMAKE_DIR}/vtkWrapperInit.data.in
    ${OUTPUT_DIR}/${TARGET}.data
    COPY_ONLY
    IMMEDIATE
    )

  # find out what kits this kit depends on
  #IF (KIT_INTERFACE_LIBS)
  #  SET(TMP_KIT_DEPENDS ${KIT_INTERFACE_LIBS})
  #ELSE (KIT_INTERFACE_LIBS)
  #  SET(TMP_KIT_DEPENDS ${KIT_LIBS})
  #ENDIF (KIT_INTERFACE_LIBS)
  # try the old LIB_DEPENDS before trying the new LINK_INTERFACE_LIBRARIES
  IF(${KIT_TARGET_NAME}_LIB_DEPENDS)
    SET(TMP_KIT_DEPENDS "${${KIT_TARGET_NAME}_LIB_DEPENDS}")
  ELSE(${KIT_TARGET_NAME}_LIB_DEPENDS)
    GET_TARGET_PROPERTY(TMP_KIT_DEPENDS "${KIT_TARGET_NAME}"
      IMPORTED_LINK_INTERFACE_LIBRARIES)
    IF(VTK_BUILD_TYPE AND NOT TMP_KIT_DEPENDS)
      STRING(TOUPPER "${VTK_BUILD_TYPE}" TMP_BUILD_TYPE_UPPER)
      GET_TARGET_PROPERTY(TMP_KIT_DEPENDS "${KIT_TARGET_NAME}"
        IMPORTED_LINK_INTERFACE_LIBRARIES_${TMP_BUILD_TYPE_UPPER})
    ENDIF(VTK_BUILD_TYPE AND NOT TMP_KIT_DEPENDS)
    IF(VTK_CONFIGURATION_TYPES AND NOT TMP_KIT_DEPENDS)
      FOREACH(TMP_CONFIG_TYPE ${VTK_CONFIGURATION_TYPES})
        STRING(TOUPPER "${TMP_CONFIG_TYPE}" TMP_CONFIG_TYPE_UPPER)
        GET_TARGET_PROPERTY(TMP_TMP_KIT_DEPENDS "${KIT_TARGET_NAME}"
          IMPORTED_LINK_INTERFACE_LIBRARIES_${TMP_CONFIG_TYPE_UPPER})
        IF(TMP_TMP_KIT_DEPENDS)
          SET(TMP_KIT_DEPENDS ${TMP_TMP_KIT_DEPENDS})
        ENDIF(TMP_TMP_KIT_DEPENDS)
      ENDFOREACH(TMP_CONFIG_TYPE)
    ENDIF(VTK_CONFIGURATION_TYPES AND NOT TMP_KIT_DEPENDS)
  ENDIF(${KIT_TARGET_NAME}_LIB_DEPENDS)

  # search for the hierarchy files for dependencies
  SET(OTHER_HIERARCHY_FILES)
  SET(QUOTED_HIERARCHY_FILES)
  SET(OTHER_HIERARCHY_TARGETS)
  FOREACH (TMP_KIT_LIB ${TMP_KIT_DEPENDS})
    IF(NOT "${TMP_KIT_LIB}" STREQUAL "${KIT_TARGET_NAME}")
      FOREACH (TMP_KIT ${VTK_KITS})
        SET(TMP_KIT_NAME ${VTK_${TMP_KIT}_NAME})
        SET(TMP_TARGET_NAME ${KIT_PREFIX}${TMP_KIT_NAME})
        IF (${TMP_KIT_LIB} STREQUAL ${TMP_TARGET_NAME})
          SET(OTHER_HIERARCHY_FILES ${OTHER_HIERARCHY_FILES}
            "${WrapVTK_BINARY_DIR}/${TMP_KIT_NAME}/${TMP_TARGET_NAME}Hierarchy.txt")
          SET(QUOTED_HIERARCHY_FILES ${QUOTED_HIERARCHY_FILES}
            "${quote}${WrapVTK_BINARY_DIR}/${TMP_KIT_NAME}/${TMP_TARGET_NAME}Hierarchy.txt${quote}")
          SET(OTHER_HIERARCHY_TARGETS ${OTHER_HIERARCHY_TARGETS}
              ${TMP_TARGET_NAME}Hierarchy)

        ENDIF (${TMP_KIT_LIB} STREQUAL ${TMP_TARGET_NAME})
      ENDFOREACH (TMP_KIT ${VTK_KITS})
    ENDIF(NOT "${TMP_KIT_LIB}" STREQUAL "${KIT_TARGET_NAME}")
  ENDFOREACH (TMP_KIT_LIB ${TMP_KIT_DEPENDS})

  IF(NOT CMAKE_GENERATOR MATCHES "Visual Studio.*")
  # build the hierarchy file: the hierarchy file is only
  # overwritten if it will changed
    ADD_CUSTOM_COMMAND(
      OUTPUT ${OUTPUT_DIR}/${TARGET}.target ${OUTPUT_DIR}/${TARGET}.txt
      DEPENDS ${VTK_WRAP_HIERARCHY_EXE} ${INPUT_FILES}
      ${OTHER_HIERARCHY_FILES}
      ${OUTPUT_DIR}/${TARGET}.data

      COMMAND ${VTK_WRAP_HIERARCHY_EXE}
      "${quote}@${RESPONSE_FILE}${quote}"
      "-o" "${quote}${OUTPUT_DIR}/${TARGET}.txt${quote}"
      "${quote}${OUTPUT_DIR}/${TARGET}.data${quote}"
      ${QUOTED_HIERARCHY_FILES}

      COMMAND ${CMAKE_COMMAND}
      "-E" "touch" "${quote}${OUTPUT_DIR}/${TARGET}.target${quote}"
      COMMENT "Hierarchy Wrapping - generating ${TARGET}.txt"
      ${verbatim}
      )
    ADD_CUSTOM_TARGET(${TARGET}
      DEPENDS ${OUTPUT_DIR}/${TARGET}.txt
      )
    IF (OTHER_HIERARCHY_TARGETS)
      ADD_DEPENDENCIES(${TARGET} ${OTHER_HIERARCHY_TARGETS})
    ENDIF (OTHER_HIERARCHY_TARGETS)
  ELSE(NOT CMAKE_GENERATOR MATCHES "Visual Studio.*")
    # On Visual Studio builds, the target-timestamp trick does not work,
    # so re-parse the header files every time and create the hierarchy
    # file if the VTK hierarchy has changed.
    ADD_CUSTOM_TARGET(
      ${TARGET} ALL
      DEPENDS ${VTK_WRAP_HIERARCHY_EXE} ${OUTPUT_DIR}/${TARGET}.data

      COMMAND ${VTK_WRAP_HIERARCHY_EXE}
      "${quote}@${RESPONSE_FILE}${quote}"
      "-o" "${quote}${OUTPUT_DIR}/${TARGET}.txt${quote}"
      "${quote}${OUTPUT_DIR}/${TARGET}.data${quote}"
      ${QUOTED_HIERARCHY_FILES}
      COMMENT "Hierarchy Wrapping - generating ${TARGET}.txt"

      ${verbatim}
      SOURCES ${INPUT_FILES}
      )
    # Set target-level dependencies to build in the correct order
    ADD_DEPENDENCIES(${TARGET} vtkWrapVTKHierarchy ${OTHER_HIERARCHY_TARGETS})
  ENDIF(NOT CMAKE_GENERATOR MATCHES "Visual Studio.*")

ENDMACRO(VTK_WRAP_HIERARCHY)
